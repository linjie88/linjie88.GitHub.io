---
title: 笔试题记录
date: 2021-1-19
categories: blog
tags: [标签一,标签二]
description: 学习总结
---
## 内存断电调试原理 ##  
内存读写断点的实现，是把相关内存页属性设置为PAGE_NOACCESS，这样当此页内内存被读写的时候会有异常传给调试器。  
当异常传给调试器时候，debugee进程被挂起，调试器把内存页属性重新修改回去，同时设置一个单步调试断点。这样debugee进程才可以正常执行过去，否则会一直被挂起。因为被设置了单步调试断点，所以执行一个指令就再次挂起，交给调试器去处理。  
这时候调试器把页面属性重新修改为PAGE_NOACCESS就可以了。  

##对于Edit控件，你如何抓防止密码框内容被抓取？##  
在处理消息事件的时候，对WM_GETTEXT和EM_GETLINE事件进行过滤  
Edit的漏洞在于没有检查发送WM_GETTEXT或EM_GETLINE消息者的身份，只要找到Edit窗口句柄，任何进程都可获取其内容。这里给出一种简单的方法来验证发送消息者的身份是否合法。   

1. 创建新CEdit类  

从CEdit继承一个子类CPasswordEdit, 申明全局变量g_bAuthorIdentity表明消息发送者的身份: 

    BOOL g_bAuthorIdentity;
    
然后响应CWnd的虚函数DefWindowProc,在这个回调函数中进行身份验证: 

    LRESULT CPasswordEdit::DefWindowProc(UINT message,
    WPARAM wParam, LPARAM lParam) 
        {
            // 对Edit的内容获取必须通过以下两个消息之一
            if(( message == WM_GETTEXT) || 
            ( message == EM_GETLINE))
            {
                // 检查是否为合法
                if( !g_bAuthorIdentity)
                {
                    // 非法获取,显示信息
                    AfxMessageBox(_T("我的密码,可不能让你看哦!"));
                    // 
                    return 0;
                }
                // 合法获取
                g_bAuthorIdentity = FALSE;
            }
            return CEdit::DefWindowProc(message, wParam, lParam);
        }
2. 在数据输入对话框中做处理 

在对话框中申明一个类成员m_edtPassword: 

    CPasswordEdit m_edtPassword;
然后在对话框的OnInitDialog()中加入下列代码: 

    m_edtPassword.SubclassDlgItem(IDC_EDIT_PASSWORD, this);
其目的是将控制与新类做关联。 

之后在对话框的数据交换中将身份设为合法: 

    void CDlgInput::DoDataExchange(CDataExchange* pDX)
    {
        // 如果获取数据
// 注意：对于CPropertyPage类这里不需要 
        if( pDX- >m_bSaveAndValidate) 条件
        if( pDX- >m_bSaveAndValidate)
        {
            g_bAuthorIdentity = TRUE;
        } 
        CDialog::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CDlgInput)
        DDX_Text(pDX, IDC_EDIT_PASSWORD, m_sPassword);
        //}}AFX_DATA_MAP
}
这样，Password输入框就会受到保护。


## DNS欺骗的方式有哪些？##  
1. hosts文件篡改  
2. 本机DNS服务器IP地址篡改，  
3. DNS通讯包篡改。
